package bibtex;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Stack;
import java.util.StringJoiner;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * Most complicated class of this package. Contains all the methods required to parse BibTeX file and generate a database
 * @author Patryk Wegrzyn
 */
public class BibtexParser {

	/**
	 * BibTeX database generated by the parser
	 */
	private BibtexDatabase database;
	/**
	 * List of saved String references
	 */
	private ArrayList<StringMacroEntry> macros;
	/**
	 * Log, used to handle String Macro definition duplicates
	 */
	private HashMap<String,String> savedMacros;
	
	//auxillary structures
	private Map<String,ArrayList<String>> required = new HashMap<>();
	private Map<String,ArrayList<String>> optional = new HashMap<>();
	private Map<String,ArrayList<ArrayList<String>>> requiredOr = new HashMap<>();
	private ArrayList<String> requiredOrs;
	private ArrayList<ArrayList<String>> listOfRequiredOrs;
	
	//regex matchers used for parsing
	private Matcher regularEntryMatcher;
	private Matcher stringMacroMatcher;
	private Matcher fieldStructureMatcher;
	private Matcher personListSplitMatcher;
	private Matcher firstCaseMatcher;
	private Matcher secondCaseMatcher;
	private Matcher zerothCaseMatcher;
	
	/**
	 * Pretty resource-heavy constructor. Initializes the used data structures, fills them with required and optional fields information, compiles all the regex patterns - 
	 * since this is a long process we run it only once, during the construction phase
	 */
	public BibtexParser() {
		
		database = new BibtexDatabase();
		
		//list with all found string macros, which are then later used as replacements
		macros = new ArrayList<StringMacroEntry>();
		
		//a log used to check whether a particular macro hasn't been saved already 
		savedMacros = new HashMap<String,String>();
		savedMacros.clear();
		
		//initialize required and optional fields for all types of entries, done only once, during the construction process
		//article
		required.put("article", new ArrayList<String>(Arrays.asList(new String[]{
			"author", "title", "year"})));
		optional.put("article", new ArrayList<String>(Arrays.asList(new String[]{
			"number", "pages", "month", "note", "key","journal","crossref","volume"})));
		
		//book
		required.put("book", new ArrayList<String>(Arrays.asList(new String[]{
			"title", "publisher", "year"})));
		optional.put("book", new ArrayList<String>(Arrays.asList(new String[]{
			"author","editor","volume", "number", "series", "address", "edition","month","note","key","crossref","booktitle"})));
		listOfRequiredOrs = new ArrayList<ArrayList<String>>();
		requiredOrs = new ArrayList<String>(Arrays.asList(new String[] {"author","editor"}));
		listOfRequiredOrs.add(requiredOrs);
		requiredOr.put("book", listOfRequiredOrs);
		
		//booklet
		required.put("booklet", new ArrayList<String>(Arrays.asList(new String[]{
			"title"})));
		optional.put("booklet", new ArrayList<String>(Arrays.asList(new String[]{
			"author","howpublished","address","month","year","note","key","crossref"})));
		
		//conference
		required.put("conference", new ArrayList<String>(Arrays.asList(new String[]{
			"author", "title","booktitle","year"})));
		optional.put("conference", new ArrayList<String>(Arrays.asList(new String[]{
			"editior","volume","number","series","pages","address","month","organization","publisher","note","key","crossref"})));
		
		//inbook
		required.put("inbook", new ArrayList<String>(Arrays.asList(new String[]{
			"title","publisher","year"})));
		optional.put("inbook", new ArrayList<String>(Arrays.asList(new String[]{
			"author","editor","chapter","pages","volume","number","series","type","address","edition","month","note","key","crossref"})));
		listOfRequiredOrs = new ArrayList<ArrayList<String>>();
		requiredOrs = new ArrayList<String>(Arrays.asList(new String[] {"author","editor"}));
		listOfRequiredOrs.add(requiredOrs);
		requiredOrs = new ArrayList<String>(Arrays.asList(new String[] {"chapter","pages"}));
		listOfRequiredOrs.add(requiredOrs);
		requiredOr.put("inbook", listOfRequiredOrs);
		
		//incollection
		required.put("incollection", new ArrayList<String>(Arrays.asList(new String[]{
			"author", "title","booktitle", "year", "publisher"})));
		optional.put("incollection", new ArrayList<String>(Arrays.asList(new String[]{
			"editor","volume","number","series","type","chapter","pages","address","edition","month","note","key","crossref"})));
		
		//inproceedings
		required.put("inproceedings", new ArrayList<String>(Arrays.asList(new String[]{
			"author", "title", "booktitle", "year"})));
		optional.put("inproceedings", new ArrayList<String>(Arrays.asList(new String[]{
			"editor","volume","number","series","pages","address","month","organization","publisher","note","key","crossref"})));
		
		//manual
		required.put("manual", new ArrayList<String>(Arrays.asList(new String[]{
			"title"})));
		optional.put("manual", new ArrayList<String>(Arrays.asList(new String[]{
			"author","organization","address","edition","month","year","note","key","crossref"})));
		
		//mastersthesis
		required.put("mastersthesis", new ArrayList<String>(Arrays.asList(new String[]{
			"author", "title","school","year"})));
		optional.put("mastersthesis", new ArrayList<String>(Arrays.asList(new String[]{
			"type","address","month","note","key","crossref"})));
		
		//misc
		required.put("misc", new ArrayList<String>(Arrays.asList(new String[]{})));
		optional.put("misc", new ArrayList<String>(Arrays.asList(new String[]{
			"author","title","howpublished","month","year","note","key","crossref"})));
		
		//phdthesis
		required.put("phdthesis", new ArrayList<String>(Arrays.asList(new String[]{
			"author", "title","school","year"})));
		optional.put("phdthesis", new ArrayList<String>(Arrays.asList(new String[]{
			"type","address", "month", "note", "key","crossref"})));
		
		//proceedings
		required.put("proceedings", new ArrayList<String>(Arrays.asList(new String[]{
			"title","year"})));
		optional.put("proceedings", new ArrayList<String>(Arrays.asList(new String[]{
			"editor","volume","number","series","address","month","publisher","organization","note","key","crossref","booktitle"})));
		
		//techreport
		required.put("techreport", new ArrayList<String>(Arrays.asList(new String[]{
			"author", "title", "institution","year"})));
		optional.put("techreport", new ArrayList<String>(Arrays.asList(new String[]{
			"type","number", "address", "month", "note", "key","crossref"})));
		
		//unpublished
		required.put("unpublished", new ArrayList<String>(Arrays.asList(new String[]{
			"author", "title","note"})));
		optional.put("unpublished", new ArrayList<String>(Arrays.asList(new String[]{
			"month", "year", "key","crossref"})));
		
		//compilation of necessary regex patterns
		//done only once, during the process of object construction
		//to save time
		Pattern regularEntryPattern = Pattern.compile("@(?!preamble|comment)([^{]+)\\{[ \\t\\r\\n\\f]*([^,=]+),((?:(?:[ \\t\\r\\n\\f]+(?:[a-zA-Z0-9]+)[ \\t\\r\\n\\f]+=[ \\t\\r\\n\\f])[^\\n]*)*)",
				Pattern.MULTILINE + Pattern.CASE_INSENSITIVE);
		regularEntryMatcher = regularEntryPattern.matcher("");
		
		Pattern stringMacroPattern = Pattern.compile("@string\\{[ \\t\\r\\n\\f]*([^ \\t\\r\\n\\f]+)(?>[ \\t\\r\\n\\f]*=[ \\t\\r\\n\\f]*\")([^\"]+)\"[ \\t\\r\\n\\f]*\\}", Pattern.CASE_INSENSITIVE);
		stringMacroMatcher = stringMacroPattern.matcher("");
		
		Pattern fieldStructurePattern = Pattern.compile(",?\\s*([a-zA-Z0-9]*)\\s*=\\s*([^\\n]+)", Pattern.CASE_INSENSITIVE);
		fieldStructureMatcher = fieldStructurePattern.matcher("");
		
		Pattern personListSplitPattern = Pattern.compile("\\s+and\\s+");
		personListSplitMatcher = personListSplitPattern.matcher("");
		
		Pattern firstCasePattern = Pattern.compile("[{\"]?([^,]+),\\s*([^$}]+)[\"}]?");
		firstCaseMatcher = firstCasePattern.matcher("");
		
		Pattern secondCasePattern = Pattern.compile("[{\"]?([^,]+),([^,]*),\\s*([^$]+)[\"}]?");
		secondCaseMatcher = secondCasePattern.matcher("");
		
		Pattern zerothCasePattern = Pattern.compile("[\"]?\\s*([^\\s]{1}[^\\s]*)(?>\\s+([^\\s]{1}[^\\s]*(?:\\s+[^\\s]+)*)+)[\"]?");
		zerothCaseMatcher = zerothCasePattern.matcher("");
		
	}
	
	/**
	 * Interface method, generates a BibTeX database object given a String containing the path to a BibTeX file
	 * @param filePath Path to the BibTeX file in a String form
	 * @return Generated BibTeX database
	 * @throws LackingRequiredFieldException Thrown when an entry doesn't have all the required fields
	 * @throws IOException Thrown when an IO error occurs
	 */
	@SuppressWarnings("unused")
	public BibtexDatabase generateDatabase(String filePath) throws LackingRequiredFieldException,IOException {
		
		File inputFile = new File(filePath);
		if(inputFile != null)
			return parseFile(inputFile);
		return null;
	
	}
	
	/**
	 * Creates and adds a new String Macro the the list of macros, but only if the log doesn't already contain such a key
	 * @param reference Key of the macro
	 * @param value Content of the macro (full version)
	 * @return Boolean status value
	 */
	public Boolean addMacro(String reference, String value) {
		
		if(savedMacros.containsKey(reference)) 
			return false;
		else {
			macros.add(new StringMacroEntry(reference, value));
			savedMacros.put(reference, value);
			return true;
		}
	}
	
	/**
	 * Main method of the class, given an input BibTeX file, it parses it, saves its content to an OOP version and return a generated database
	 * @param inputFile BibTeX file
	 * @return Generated database
	 * @throws IOException Thrown when an IO error occurs
	 * @throws LackingRequiredFieldException Thrown when an entry doens't have all the required fields
	 */
	private BibtexDatabase parseFile(File inputFile) throws IOException, LackingRequiredFieldException {
		
		String entryKey, entryType, fieldName, fieldValue;
		String[] splitFieldValue;
		StringBuilder builder;
		String content;
		int inputChar;
		RegularEntry regularEntry;
		
		/*
		 * I use a StringBuilder, because operating on a normal String (concatenations etc)
		 * would be too time consuming
		 */
		builder = new StringBuilder();
		
		//java 8 try-with-resources style
		try (BufferedReader br = new BufferedReader(new FileReader(inputFile))) {

			while ((inputChar = br.read()) != -1) {
				builder.append((char) inputChar);
			}

		}

		//create the full String of the file
		content = builder.toString();
		
		//find and save all @stringMacros
		stringMacroMatcher.reset(content);
		while(stringMacroMatcher.find()) {
			
			String reference = stringMacroMatcher.group(1);
			String value = stringMacroMatcher.group(2);
			addMacro(reference, value);
		
		}
		database.setStringMacros(macros);
		
		//iterate through the whole file looking for regular entries
		regularEntryMatcher.reset(content);
		while(regularEntryMatcher.find()) {
			
			entryType = regularEntryMatcher.group(1).toLowerCase().trim();
			if(isValidRegularEntry(entryType)) {
				
				entryKey = regularEntryMatcher.group(2).trim();
				
				regularEntry = this.database.createRegularEntry(entryType, entryKey);
				
				//iterate through each field in the field list
				fieldStructureMatcher.reset(regularEntryMatcher.group(3));
				while(fieldStructureMatcher.find()){
					
					//get the field name
					fieldName = fieldStructureMatcher.group(1).toLowerCase().trim();
					
					//check if we really want to save this field,
					if(isNotIgnored(entryType, fieldName)) {
						
						//split by " # " looking for StringMacro references
						//but first remove the endline char, which got caputed by the regex pattern
						String noEndline = fieldStructureMatcher.group(2).substring(0, fieldStructureMatcher.group(2).length()-1);
						fieldValue = noEndline;
						splitFieldValue = fieldValue.split(" # ");
	
						StringJoiner dereferencedFieldValue = new StringJoiner(" ");
						
						for(int i=0; i<splitFieldValue.length; i++) {
							
							if(splitFieldValue[i].charAt(splitFieldValue[i].length()-1) == ',')
								splitFieldValue[i] = splitFieldValue[i].substring(0, splitFieldValue[i].length()-1);
							//if it's not enclosed this means its not a literal and it is supposed to be dereferenced
							if(!isSurroundedByQuotes(splitFieldValue[i].trim())) {
								
								for(StringMacroEntry macro : macros) {
									
									//if we have such a macro reference, dereference it, else skip
									if(macro.getEntryKey().trim().equals(splitFieldValue[i].trim())) {
										splitFieldValue[i] = macro.getValue();
									}
								}
							}
							//clear off brackets and quotes
							splitFieldValue[i] = removeMargins(splitFieldValue[i]);
							
							//slowly build the dereferenced, concatenated filedValue,
							//mind that we use StringJoiner with space delimiter 
							//since we removed the spaces during the splitting process
							dereferencedFieldValue.add(splitFieldValue[i]);
						}
						
						//save the parsedString to the HashMap of fields of the new Entry
						String parsedFieldValue = dereferencedFieldValue.toString();
						ParsedString parsedString = database.createString(parsedFieldValue);
						regularEntry.setField(fieldName, parsedString);
					}
					
				}
				
				//if the entry contains the field author we must replace it with a personList
				if (regularEntry.getFieldValue("author") != null) {
					regularEntry.setField("author", generatePersonListFromString((ParsedString) regularEntry.getFieldValue("author")));
				}
				
				//same with editior
				if (regularEntry.getFieldValue("editor") != null) {
					regularEntry.setField("editor", generatePersonListFromString((ParsedString) regularEntry.getFieldValue("editor")));
				}
				
				this.database.addEntry(regularEntry);
				
			}

		}
		
		LinkedHashMap<String,AbstractEntry> myMap = database.getEntriesMap();
		for (Map.Entry<String, AbstractEntry> entry : myMap.entrySet()) {
			//dereferention of crossreferences, not sure if necessary or not..
			if (((RegularEntry)entry.getValue()).getFieldValue("crossref") != null)
				dereferenceCrossReferences(((RegularEntry)entry.getValue()));
			//check if all required fields were provided or field is crossreferenced
			if (!hasAllRequiredFields((RegularEntry) entry.getValue()) && !isCrossreferenced((RegularEntry) entry.getValue()))
				throw new LackingRequiredFieldException(
						"One or more required fields are lacking in the entry: " + entry.getValue().getEntryKey());
		}
		
		return database;
		
	}
	
	/**
	 * Checks if a passed field is not ignored within a given entry context (is required or optional)
	 * @param type Type of the entry
	 * @param field Name of the field to be checked
	 * @return Boolean status flag of the checking process
	 */
	private boolean isNotIgnored (String type, String field) {
		
		//if it fits just one, it's not ignored
		ArrayList<String> requiredFields = this.required.get(type);
		for(String s : requiredFields) {
			if(s.equals(field))
				return true;
		}
		
		//same in here
		ArrayList<String> optionalFields = this.optional.get(type);
		for(String s : optionalFields) {
			if(s.equals(field))
				return true;
		}
		
		//if it doesn't fit anything, it's ignored
		return false;
		
	}
	
	/**
	 * Checks whether a given entry type is recognized by the system
	 * @param entryType Type of the entry
	 * @return Boolean status flag
	 */
	private boolean isValidRegularEntry (String entryType) {
		
		return optional.containsKey(entryType);
		
	}
	
	/**
	 * Checks whether a given RegularEntry objects contains all the required fields 
	 * @param entry Entry to be check
	 * @return Boolean status flag
	 */
	private boolean hasAllRequiredFields(RegularEntry entry) {
		
		//required, non-exchangeable fields
		ArrayList<String> requiredFields = this.required.get(entry.getEntryType());
		for(String requiredField : requiredFields) {
			
			if(entry.getFieldValue(requiredField) == null) return false;
			
		}
		
		//required, exchangeable fields
		ArrayList<ArrayList<String>> pairsOfReqFields = this.requiredOr.get(entry.getEntryType());
		
		if (pairsOfReqFields != null) {
			for (ArrayList<String> pair : pairsOfReqFields) {

				if (pair.get(0) == null && pair.get(1) == null)
					return false;

			} 
		}
		//if both loops have passed, then entry has all required entries
		return true;
		
	}
	
	
	/**
	 * Creates a PersonList object given an ParsedString input String (concatenated list of authors or editors)
	 * @param inputString Original, concatenated string
	 * @return Generated list of people
	 */
	private PersonList generatePersonListFromString(ParsedString inputString) {
		
		String firstName;
		String lastName;
		
		personListSplitMatcher.reset(inputString.getContent());
		
		if(personListSplitMatcher.find()) {
			
			String replacedInputString = personListSplitMatcher.replaceAll("@");
			inputString.setContent(replacedInputString);
			
		}
		
		String[] peopleTable = inputString.getContent().split("@");
		PersonList peopleList = this.database.createPersonList();
		
		for(int i=0; i<peopleTable.length; i++) {
			
			String temp = peopleTable[i];
			int howManyComas = temp.length() - temp.replaceAll(",","").length();
			
			peopleTable[i] = peopleTable[i].trim();
			
			//depending on how many comas we have, we choose the right BiBTeX format
			switch(howManyComas) {
			
				case 0:
					zerothCaseMatcher.reset(peopleTable[i]);
					zerothCaseMatcher.find();
					firstName = zerothCaseMatcher.group(1).trim();
					lastName = zerothCaseMatcher.group(2).trim();
					break;
				
				case 1:
					firstCaseMatcher.reset(peopleTable[i]);
					firstCaseMatcher.find();
					firstName = firstCaseMatcher.group(2).trim();
					lastName = firstCaseMatcher.group(1).trim();
					break;
				
				case 2:
					secondCaseMatcher.reset(peopleTable[i]);
					secondCaseMatcher.find();
					firstName = secondCaseMatcher.group(3).trim();
					lastName = (secondCaseMatcher.group(1) + " " + secondCaseMatcher.group(2)).replaceAll("\\s{2,}", " ").trim();
					break;
				
				default: 
					throw new IllegalArgumentException(); 
			
			}
			
			Person newPerson = this.database.createPerson(firstName, lastName);
			peopleList.addPersonToList(newPerson);
			
		}
		
		return peopleList;
	}
	
	/**
	 * Checks whether a String is surrounded with quotation marks, uses regular expressions
	 * @param input String to be tested
	 * @return Boolean status flag
	 */
	private boolean isSurroundedByQuotes(String input) {
		
		Pattern tempPattern = Pattern.compile("^\\s*\"\\s*([^\"]+)\"\\s*");
		Matcher tempMatcher = tempPattern.matcher("");
		tempMatcher.reset(input.trim());
		if(tempMatcher.find()) {
			return true;
		}
		return false;
		
	}
	
	/**
	 * Removes the leftmost and rightmost quotation marks or brackets,
	 * but only if the produced String is a balanced expression (bracket-wise)
	 * @param input Input String object
	 * @return New String object
	 */
	private String removeMargins(String input) {
		
		String temp=input;
		
		if (input.length() > 0) {
			if (input.charAt(input.length() - 1) == '"')
				input = input.substring(0, input.length() - 1);
			if (input.length() > 0 && input.charAt(0) == '"')
				input = input.substring(1, input.length());
			
			temp = input;
			
			if (input.length() > 0 && input.charAt(0) == '{' && input.charAt(input.length() - 1) == '}') {
				input = input.substring(0, input.length() - 1);
				input = input.substring(1, input.length());
				
				input = isBalancedExpression(input) ? input : temp;
			} 
		}
		return input;
		
	}
	
	/**
	 * Checks whether a given input String object is a balanced expression (bracket-wise)
	 * @param input Input String object
	 * @return Boolean status flag
	 */
	private boolean isBalancedExpression(String input) {
        
		Stack<Character> stack = new Stack<>();
		
		//go through the string and check if pairs of tokens match
        for(char token : input.toCharArray()) {
            
        	switch(token) {

                case ']':
                    if(stack.isEmpty() || stack.pop() != '[') 
                        return false;
                    break;
                    
                case ')':
                    if(stack.isEmpty() || stack.pop() != '(')
                        return false;
                    break;
                    
                case '}':
                    if(stack.isEmpty() || stack.pop() != '{')
                        return false;
                    break;
                    
                case '{':
                case '(':
                case '[':
                    stack.push(token);
                    break;
            }
        }
        return stack.isEmpty();
    }
	
	/**
	 * Support method, dereferences a entry containing a crossref field
	 * @param entry Regular entry, containing a crossref field
	 */
	private void dereferenceCrossReferences(RegularEntry entry) {
		
		ParsedString crossref = (ParsedString) entry.getFieldValue("crossref");
		
		LinkedHashMap<String,AbstractEntry> myMap = this.database.getEntriesMap();
		
		RegularEntry crossreferenced;
		
		if(myMap.get(crossref.getContent()) != null) {
			crossreferenced = (RegularEntry) myMap.get(crossref.getContent());
		} else if(myMap.get(crossref.getContent().toLowerCase()) != null) {
			crossreferenced = (RegularEntry) myMap.get(crossref.getContent().toLowerCase());
		} else if((myMap.get(crossref.getContent().toUpperCase()) != null)) {
			crossreferenced = (RegularEntry) myMap.get(crossref.getContent().toUpperCase());
		} else {
			return;
		}
		
		LinkedHashMap<String,AbstractFieldValue> myFields = crossreferenced.getFieldsMap();
		
		for(Map.Entry<String, AbstractFieldValue> field : myFields.entrySet()) {
			
			if(entry.getFieldValue(field.getKey()) == null) {
				
				entry.setField(field.getKey(), field.getValue());
				
			}
			
		}
		
	}
	
	/**
	 * Checks if a regular entry is being crossreferenced somewhere else in the file
	 * @param entry the entry that is going to check for being referenced
	 * @return the boolean value, which states if the passed entry is crossreferenced in the file
	 */
	private boolean isCrossreferenced(RegularEntry entry) {
		
		String key = entry.getEntryKey();
		LinkedHashMap<String,AbstractEntry> myMap = this.database.getEntriesMap();

		for (Map.Entry<String, AbstractEntry> ent : myMap.entrySet()) {
			
			if((((ParsedString)((RegularEntry) ent.getValue()).getFieldValue("crossref"))) != null) {
			
				if ((((ParsedString)((RegularEntry) ent.getValue()).getFieldValue("crossref")).getContent()).equalsIgnoreCase(key)) {
					return true;
				}
	
			}
		}
		return false;
	}
	
}
